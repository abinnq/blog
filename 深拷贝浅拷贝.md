# 深拷贝浅拷贝
深拷贝于浅拷贝的主要区别就是其在内存中存储类型不同

**1.栈**
栈(stack): 自动分配的内存空间, 它由系统自动释放, 数据大小确定, 按值存放, 可以直接访问;
  存放的是基本数据类型: number、string、null、 undefined、boolean

**2.堆**
堆(heap): 动态分配的内存, 大小不定也不会自动释放;

**3.基本数据类型值不可变**
字符串中所有的方法看似返回了一个修改后的字符串, 实际返回的是一个新的字符串值
```type='typescript'
let str = 'abc';
str[0] = 'e';
console.log(str); // 'abc'
```

**4.基本数据类型的比较是值的比较**
基本类型的比较是值的比较, 值相等即相等
`==` 会进行类型转换
```type='javascript'
let a = 'abc';
let b = 'abc';
console.log(a === b); // true
```

**5.引用类型放在堆中**
引用类型是存放在堆内存中,变量实际上是存放在栈内存的指针, 该指针指向堆内存中的地址。
```type='javascript'
let person1 = {name: 'abin'};
let person2 = {name: 'tom'};
```
```
       栈区                堆区
person1  堆内存地址1  -->  object1
person2  堆内存地址2  -->  object2
```

**6.引用类型值可变**
引用类型的值可以直接改变
```type='javascript'
let arr = [1,2,3];
arr[0] = 'a';
console.log(arr); // ['a', 2, 3]
```

**7.引用类型的比较是引用的比较**
每次对引用类型进行操作时, 都是其操作对象的引用(保存在栈内存的指针), 比较两个引用类型, 是看其引用是不是同一个对象.
```type='javascript'
let a = [1,2,3];
let b = [1,2,3];
console.log(a === b); // false
```
虽然a 和 b 都表示一个1,2,3的数组, 但是其在内存中的位置不一样, 即不指向同一个引用对象, 故不相等;

**8.传值与传址**
*基本数据类型传值*
基本数据类型的赋值(=) 是在内存中新开辟一段栈内存, 然后再将值赋值到新的栈中;
基本类型的赋值中,两个变量是独立且不相互影响的。
```type='javascript'
let a = 1;
let b = a;
a += 1;
console.log(a, b); // a: 2, b: 1

初始化b前的栈区   ->   初始化b后的栈区
  a   10              a    10
                      b    10   
```
*引用类型传址*
引用类型的赋值是传址, 只改变指针的指向。
引用类型的赋值是对象保存在栈中堆地址的赋值, 这样两个变量就指向同一个堆内存地址, 两者之间的相互操作有影响。
```type='javascript'
let a = {};
let b = a;
a.name = 'abin';
console.log(a, b); // {name: 'abin'}  {name: 'abin'}
```

```             
  给b初始化前的栈区         堆区内存
    a     堆地址1       堆内存1: {} a.name -> {name: 'abin'}

  给b初始化后的栈区   
    a     堆地址1
    b     堆地址1   
``` 
**浅拷贝**
使用Object.assign, 或者通过`...` 运算符;
浅拷贝:  只复制第一层数据, 第一层数据是基础类型数据为新建, 引用类型数据则复制其引用;
```type='javascript'
let a = {age: 18, name: 'abin', pet: {food: 'fish'}};
let b = {...a};
b.name = 'blue';
b.pet.food = 'bone';
console.log(a.name, b.name); // 'abin'、'blue'
console.log(a.pet, b.pet); // {food: 'fish'}, {food: 'bone'}
```


**深拷贝**
通常使用`JSON.parse(JSON.stringify(Object))` 来深度拷贝。
```type='javascript'
let a = {age: 18, name: 'abin', pet: {food: 'fish'}};
let b = JSON.parse(JSON.stringify(a));
b.pet.food = 'bone';
console.log(a.pet); // {food: 'fish'}
```

```type='javascript'
let a = {
  name: 'abin',
  age: undefined,
  jobs: function() {},
  sex: Symbol('male'),
}
let b = JSON.parse(JSON.stringify(a)); 
console.log(b); // {name: 'abin'}
```
缺点: 
  1. 不能解决循环引用的对象
  2. 会忽略 `undefined`
  3. 会忽略 `symbol`
  4. 不能序列化函数
优点: 内置函数中处理很快 性能不错。

使用递归进行深拷贝:
```type='javascript'
  function deepClone(obj) {
    if(obj === null) return null;
    if(typeof obj !== 'object') return obj;
    let target = new obj.constructor();
    for(let key in obj) {
      target[key] = deepClone(obj[key]);
    }
    return target;
  }
```

**赋值和浅拷贝深拷贝的区标**
|---| 和原数据是否指向统一对象|第一层数据为基本类型|原数据中包含子对象|
|---|---|---|---|
|赋值|是|会使原数据一同改变|会使原数据一同改变|
|浅拷贝|否|不会使原数据改变统一对象|会使原数据统一改变|
|深拷贝|否|不会使原数据改变统一对象|不会使原数据统一改变|

赋值: 基础类型新建, 引用类型指针指向同一引用。
浅拷贝: 只复制第一层数据, 第一层数据是基础类型数据为新建, 引用类型数据则复制其引用。
深拷贝: 对于非基本类型的变量,递归至基本类型变量后复制, 深拷贝后的对象与原对象是完全隔离的互不影响。