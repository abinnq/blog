## 事件机制
**事件冒泡**
  从当前触发的事件目标一级一级的向上传递，以此触发，直到document为止。

**事件捕获**
  会从document开始触发，一级一级向下传递， 直到真正事件目标为止。


```type='javascript'
node.addEventListener('click', Function, useCapture)
```
useCapture: Boolean || Object
1. Boolean: 
  true: 事件捕获
  false: 冒泡

2. Object：
  - `capture`: Boolean, 和`useCapture`作用一样
  - `once`: Boolean， 为true时表示该回调只会调用一次，调用后会移除监听
  - `passive`: Boolean, 表示永远不会调用`preventDefault` 

**阻止事件冒泡或捕获** 
  event.stopPropagation();
  event.stopImmediatePropagation(); 也可以阻止

**事件委托**
又称 事件代理： 需要子节点注册事件时直接给父节点注册事件
优点：
  - 节省内存
  - 不需要给子节点注册事件
　
# Event loop
**1、进程和线程**
  - 进程: cpu运行的单个任务, 单个cpu只能运行一个任务
  - 线程: 一个进程包括多个线程, 多个线程共享进程资源。浏览器中线程(渲染线程、JS引擎线程、HTTP请求线程)

**2、单线程和非阻塞**
  - 单线程: 最初的js 就是为了和浏览器交互的, 如果多线程: 一个线程删除DOM, 一个新增, 就要引入读写解锁这个问题。
  - 非阻塞: 是为了在操控dom 的时候,其他的事件也可以触发

**3、任务队列**
  - js分为同步任务和异步任务, 
  - 同步任务都在主线程上执行,形成一个执行栈
  - 主线程外, 事件触发线程管理着一个任务队列, 异步任务有了运行结果就在任务队列中放置一个事件
  - 一旦执行栈中的所有同步任务执行完成后, 系统就会读取任务队列, 将可运行的异步任务添加到执行栈中, 开始执行

**4、宏任务**
  - 每次执行栈中执行的代码都是宏任务, es6 称为task
  - 浏览器为了能够时js内部与DOM任务有序进行, 会在宏任务执行完成后, 下一个宏任务执行前, 对页面进行渲染
  - 宏任务: script、setTimeout、setInterval、I/O, UI交互事件

**5、微任务**
  - 当前task执行结束后立即执行的任务, task -> 微任务 -> 页面渲染
  - 微任务: promise.then

**6、运行机制**
 每一次的循环称为tick
  - 执行一个宏任务(栈中没有就从事件队列中取)
  - 执行过程中遇到微任务就将其添加到微任务队列
  - 宏任务执行完毕后, 立即依次执行微任务队列中微任务
  - GUI线程接管渲染
  - 继续下一个宏任务
